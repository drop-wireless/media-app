import EncryptedStorage from 'react-native-encrypted-storage';
import {createAsyncThunk, createSlice, PayloadAction} from '@reduxjs/toolkit';
// import {RootState, AppThunk} from '../store';

export interface UserState {
  userId: string;
  userName: string;
  email: string;
  signedIn: boolean;
  walletAddress: string;
  location: {latitude: number; longitude: number};
  credits: number;
  skipWalletAddress: boolean;
  internetReachable: boolean;
}

const initialState: UserState = {
  userId: '',
  userName: '',
  email: '',
  signedIn: false,
  walletAddress: '',
  location: {latitude: 0, longitude: 0},
  credits: 0,
  skipWalletAddress: false,
  internetReachable: false
};

export const signInAsync = createAsyncThunk(
  'user/signIn',
  async (userId: string, {getState}) => {
    // skip this to store privat keys.....
    // const state: any = getState();
    // if (userId !== state.userId) {
    //   try {
    //     await EncryptedStorage.clear();
    //   } catch (err) {
    //     console.log('EncryptedStorage clear err:', err);
    //   }
    // }
    return userId;
  },
);

export const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    setWalletAddress: (state, action: PayloadAction<string>) => {
      state.walletAddress = action.payload;
    },
    setUserName: (state, action: PayloadAction<string>) => {
      state.userName = action.payload;
    },
    setEmail: (state, action: PayloadAction<string>) => {
      state.email = action.payload;
    },
    updateUserLocation: (
      state,
      action: PayloadAction<{latitude: number; longitude: number}>,
    ) => {
      state.location = action.payload;
    },
    logOut: state => {
      state.email = '';
      state.userName = '';
      state.signedIn = false;

      state.walletAddress = '';
      state.skipWalletAddress = false;
      state.credits = 0;
    },
    updateCredits: (
      state,
      action: PayloadAction<number>,
    ) => {
      state.credits = action.payload;
    },
    setSkipWalletAddress: (
      state,
      action: PayloadAction<boolean>,
    ) => {
      state.skipWalletAddress = action.payload;
    },
    setInternetReachable: (
      state,
      action: PayloadAction<boolean>,
    ) => {
      state.internetReachable = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
      .addCase(signInAsync.pending, state => {})
      .addCase(signInAsync.fulfilled, (state, action) => {
        if (action.payload !== state.userId) {
          state.walletAddress = '';
          state.userId = action.payload;
        }
        state.signedIn = true;
      })
      .addCase(signInAsync.rejected, state => {});
  },
});

export const {
  setWalletAddress,
  setUserName,
  setEmail,
  updateUserLocation,
  logOut,
  updateCredits,
  setSkipWalletAddress,
  setInternetReachable,
} = userSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
// export const selectCount = (state: RootState) => state.counter.value;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd =
//   (amount: number): AppThunk =>
//   (dispatch, getState) => {
//     const currentValue = selectCount(getState());
//     if (currentValue % 2 === 1) {
//       dispatch(incrementByAmount(amount));
//     }
//   };

export default userSlice.reducer;
